<dom-module id="timeline-overlay-anchors">
    <style>
        :host {
            display: block;
            position: absolute;
            height: 100%;
            top: 0;
            left: 3px;
            right: 3px;
        }

        .timeline-overlay-anchor {
            display: block;
            background-color: darkorange;
            transition: opacity 0.1s, background-color 0.1s;
            position: absolute;
            width: 4px;
            height: 100%;
            margin-left: -2px;
            opacity: 0.6;
        }

        .timeline-overlay-anchor:hover {
            opacity: 1;
        }
    </style>
    <template>
        <template id="anchors" is='dom-repeat' items='{{overlays}}' filter="_isTimedQuiz" observe="type events">
            <div class="timeline-overlay-anchor" style$="{{_anchorStyle(item.events.*, _videoDuration)}}" on-mousedown="_stopPropagation" on-click="_jumpToOverlay"></div>
        </template>
    </template>
</dom-module>
<script>
(function() {
    'use strict';
    
    Polymer({
        is: 'timeline-overlay-anchors',
        properties: {
            overlays: Array,
            _videoDuration: Number
        },
        attached: function() {
            // in the player establish a faky data binding (see below)
            if (window.isPlayer) {
                var overlaysManager = document.getElementById('overlays');
                overlaysManager.addEventListener('overlays-changed', this._overlaysChanged.bind(this));
                this.set('overlays', overlaysManager.overlays);
            }

            // Set the video duration as soon as the video is ready. As in the editor the video player gets
            // initialized after Polymer is ready we have to wait until the player is available. This is somewhat
            // hacky but not to bad as it only is relevant in the editor. 
            var that = this;
            function setVideoDuration() {
                if (window.player && window.player.isReady && window.player.isReady()) {
                    that.set('_videoDuration', window.player.getDuration());
                } else {
                    setTimeout(setVideoDuration, 200);
                }
            }
            setVideoDuration();
        },
        /**
        * The _overlayChanged callback serves for establishing a one way data binding to the overlays in the player.
        * As the <timeline-overlay-anchors> element sits outside the dom-bind #app element, we can not directly
        * data bind to it using Polymers data binding. We can not put the <timeline-overlay-anchors> into the
        * dom-bind element, as it has to sit in the <video-controls> element for the correct style, as we want
        * it to be above the timeline but below the timeline label.
        * Therefore we establish our own databinding using the 'overlays-changed'. The data itself does not
        * need to be updated as we use the same reference to the overlays as the <overlays-manager> does.
        * We however need to propagate data change notifications from Polymers 'overlays-changed' event on the
        * <overlays-manager> element to the <timeline-overlay-anchors> element itself.
        */
        _overlaysChanged: function(event) {
            // promote the change using notifyPath. The notification gets triggered after a dirtycheck to the
            // second parameter, therefore we hand in an empty object to always trigger the notification that
            // we want.
            // We filter out only those notifications that we are interested in by a regular expression.
            if (/overlays\.splices|overlays\.\d+\.type|overlays\.\d+\.events/.test(event.detail.path)) {
                this.notifyPath(event.detail.path, {}, true); 
            }
        },
        /**
        * returns true for a given overlay, if the overlay is a quiz and is triggered by a timestamp
        */
        _isTimedQuiz: function(overlay) {
            if (overlay.type.indexOf('quiz')===-1 || !overlay.events) {
                return false;
            }
            for (var i=0; i<overlay.events.length; ++i) {
                var eventType = overlay.events[i].type;
                if (eventType === 'STOP' || eventType === 'PLAYAFTER' || eventType === 'HIDEAFTER') {
                    return true;
                }
            }
            return false;
        },
        /**
        * Returns a style string for the position of an anchor, eg: "left:30%;"
        */
        _anchorStyle: function(overlayEventsChangeRecord, videoDuration) {
            var events = overlayEventsChangeRecord.base;
            if (!events) {
                return ''; // this should never happen due to the filter but who knows
            }
            var styleString = '';
            for (var i=0; i<events.length; ++i) {
                var eventType = events[i].type;
                if (eventType === 'STOP' || eventType === 'PLAYAFTER' || eventType === 'HIDEAFTER') {
                    styleString += 'left:'+(100 * events[i].start / videoDuration)+'%;';
                }
            }
            return styleString;
        },
        _stopPropagation: function(event) {
            event.stopPropagation(); // dont trigger the mousedown of the timeline
        },
        _jumpToOverlay: function(event) {
            event.stopPropagation();
            EventTimer.seekTo(event.model.item);
        }
    });
})();
</script>