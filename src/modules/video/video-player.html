<dom-module id="video-player">
    <style>
        :host {
            display: block;
            height: 100%;
        }

        :host > ::content > * {
            height: 100%;
        }
    </style>
    <template>
        <content></content>
        <video-controls id="video-controls" overlays="{{overlays}}" state="{{state}}" duration="{{duration}}" position="{{position}}" video-started="{{started}}"></video-controls>
    </template>
</dom-module>
<script>
'use strict';
(function() {
    Polymer({
        is: 'video-player',
        properties: {
            video: {
                type: Object
            },
            started: {
                type: Boolean,
                value: false
            },
            duration: {
                type: Number,
                notify: true
            },
            position: {
                type: Number,
                notify: true
            },
            state: {
                type: String,
                notify: true
            },
            overlays: {
                type: Array
            },
            _playerInstance: Object,
            _eventTimerActivated: {
                type: Boolean,
                value: false
            },
            _eventTimerCallback: Object
        },
        observers: ['_loadVideo(video.*)'],
        attached: function() {
            if (window.isPlayer) {
                function executeWhenUnitLoaded() {
                    // in the player the player implementation gets pre assigned to window.player
                    var player = window.player;
                    window.player = this;
                    app.player = this;
                    this._changeVideoPlayer(player);
                    // As the <video-player> element in the capira player sits outside the dom-bind #app
                    // element, we can not directly data bind to it using Polymers data binding. We however
                    // want the <video-player> element to stay in light DOM, outside the <template
                    // is="dom-bind"> such that the video can start loading immediately when the page is
                    // loaded without waiting for Polymer. Thus, we simply set the parameters initially,
                    // without databinding for now in the player.
                    this.video = app.unit.video;
                }
                if (app.unit) {
                    executeWhenUnitLoaded.call(this);
                } else {
                    window.app.addEventListener('unit-loaded', executeWhenUnitLoaded.bind(this));
                }
            }
            window.player = this;
            app.player = this;
        },
        _loadVideo: function() {
            if (!this._playerInstance || this._playerInstance.getType() !== this.video.type) {
                // have to change the _playerInstance
                var apiName;
                if (this.video.type === 'youtube') {
                    apiName = 'VideoPlayerYoutube';
                }
                this._loadPlayerApi(apiName, function() {
                    var domElement = Polymer.dom(this).firstChild;
                    if (!domElement) {
                        domElement = document.createElement('div');
                        Polymer.dom(this).appendChild(domElement);
                    }
                    var newPlayer = new window[apiName](this.video, domElement);
                    this._changeVideoPlayer(newPlayer);
                }.bind(this));
            } else if (this._playerInstance.getSource() !== this.video.source) {
                this._playerInstance.loadVideo(this.video);
            }
        },
        /**
        * for lazy loading the required APIs
        */
        _loadPlayerApi: function(apiName, callback) {
            if (!window[apiName]) {
                // API needs to get loaded
                var filesToLoad = [];
                var loadedScripts = {};
                if (!window.VideoPlayerBase) {
                    filesToLoad.push('../modules/video/video-player-base-init.js');
                    filesToLoad.push('../modules/video/video-player-base-api.js');
                }
                if (apiName === 'VideoPlayerYoutube') {
                    filesToLoad.push('../modules/video/video-player-youtube/video-player-youtube-init.js');
                    filesToLoad.push('../modules/video/video-player-youtube/video-player-youtube-api.js');
                }
                if (!window.EventTimer) {
                    filesToLoad.push('../modules/video/event-timer.js');
                }

                // download the files asynchronously and execute them in correct order
                filesToLoad.forEach(function(fileToLoad) {
                    var request = new XMLHttpRequest();
                    request.open('GET', fileToLoad);
                    request.onload = function() {
                        if (request.status === 200) {
                            var scriptText = request.response;
                            loadedScripts[fileToLoad] = scriptText;
                            executeScriptsInOrder();
                        }
                    };
                    request.send();
                });

                function executeScriptsInOrder() {
                    var nextFile; // next file to handle is always the first in the filesToLoad list
                    while ((nextFile=filesToLoad[0]) && (loadedScripts[nextFile])) {
                        eval(loadedScripts[nextFile]);
                        filesToLoad.splice(0,1); // remove handled file
                        delete loadedScripts[nextFile];
                    }
                    if (filesToLoad.length===0 && callback) {
                        callback();
                    }
                }
            } else {
                if (callback) {
                    callback();
                }
            }
        },
        _changeVideoPlayer: function(newPlayer) {
            var oldPlayer = this._playerInstance;
            var dontOverWrite = [];
            for (var property in this.constructor.prototype) {
                dontOverWrite.push(property);
            }

            if (oldPlayer) {
                // fre up old method bindings
                for (var method in oldPlayer) {
                    if (method.charAt(0)!=='_' && dontOverWrite.indexOf(method) === -1) {
                        delete this[property];
                    }
                }
                // TODO free up old player eventlisteners etc.
            }

            // set new method bindings for public API of the player Implementation
            for (var method in newPlayer) {
                if (method.charAt(0)!=='_' && dontOverWrite.indexOf(method) === -1) {
                    this[method] = newPlayer[method].bind(newPlayer);
                }
            }

            var that = this;
            newPlayer.on('timechange', function(time) {
                that.position = time;
            });
            newPlayer.on('videochange', function() {
                that.duration = newPlayer.getDuration();
            });
            newPlayer.on('play', function() {
                that.state = 'play';
            });
            newPlayer.on('pause', function() {
                that.state = 'pause';
            });
            that.duration = newPlayer.getDuration();
            if (!this.started) {
                if (newPlayer.isReady() && newPlayer.isPlaying()) {
                    this.started = true;
                } else {
                    newPlayer.once('start', function() {
                        this.started = true;
                    }.bind(this));
                }
            }

            this._playerInstance = newPlayer;

            if (!this._eventTimerActivated) {
                this._setEventTimerReady();
            }
        },
        _setEventTimerReady: function() {
            this._eventTimerActivated = true;
            window.EventTimer.init();
            window.EventTimer.start();
            if (this._eventTimerCallback) {
                window.EventTimer.setCallback(this._eventTimerCallback);
            }
            window.document.dispatchEvent(new Event('eventtimer-ready'));
        },

        setEventTimerCallback: function(callback) {
            this._eventTimerCallback = callback;
            if (this._eventTimerActivated) {
                window.EventTimer.setCallback(callback);
            }
        }
    });
})();
</script>
